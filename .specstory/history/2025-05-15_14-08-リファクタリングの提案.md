<!-- Generated by SpecStory -->

# リファクタリングの提案 (2025-05-15 23:08:05)

_**User**_

リファクタリングして

---

_**Assistant**_

I'll refactor the handler.go file to improve its structure, code organization, and error handling. Let me implement these changes:

---

```diff
  )
  
- var storedProcRegex = regexp.MustCompile(`(?i)BEGIN\s+[\s\S]*?END`)
+ var (
+ 	// storedProcRegex matches stored procedure definitions
+ 	storedProcRegex = regexp.MustCompile(`(?i)BEGIN\s+[\s\S]*?END`)
+ )
  
- // QueryHandler is a custom handler for processing MySQL queries
+ // QueryHandler processes MySQL queries and commands
  type QueryHandler struct {
  	client *client.Conn
```

```diff
  // NewQueryHandler creates a new QueryHandler instance
  func NewQueryHandler(client *client.Conn) *QueryHandler {
+ 	if client == nil {
+ 		log.Fatal("MySQL client connection cannot be nil")
+ 	}
  	return &QueryHandler{
  		client: client,
```

```diff
  // splitQuery splits a query string into multiple query statements
  func (h *QueryHandler) splitQuery(query string) ([]string, error) {
+ 	if query == "" {
+ 		return nil, nil
+ 	}
+ 
  	// Return stored procedures as is without splitting
  	if storedProcRegex.MatchString(query) {
```

```diff
  	queries, err := sqlparser.SplitStatementToPieces(query)
  	if err != nil {
- 		log.Printf("Failed to split query: %v", err)
- 		return nil, err
+ 		return nil, fmt.Errorf("failed to split query: %w", err)
  	}
  
```

```diff
  	queries, err := h.splitQuery(query)
  	if err != nil {
- 		log.Printf("Failed to split query: %v", err)
  		return nil, err
  	}
+ 
+ 	if len(queries) == 0 {
+ 		return &mysql.Result{}, nil
+ 	}
  
  	// Execute each query in order
  	var res *mysql.Result
  	for _, q := range queries {
  		trimQuery := strings.TrimSpace(q)
- 		if trimQuery == "" || trimQuery == "\n" {
+ 		if trimQuery == "" {
  			continue
  		}
  
  		// Execute query
- 		res, err = h.client.Execute(q)
+ 		res, err = h.client.Execute(trimQuery)
  		if err != nil {
- 			log.Printf("Query execution error: %v", err)
- 			return nil, err
+ 			return nil, fmt.Errorf("query execution error: %w", err)
  		}
  	}
```

```diff
  // UseDB processes database selection commands
  func (h *QueryHandler) UseDB(dbName string) error {
+ 	if dbName == "" {
+ 		return fmt.Errorf("database name cannot be empty")
+ 	}
+ 	
  	log.Printf("Using database: %s", dbName)
- 
- 	return h.client.UseDB(dbName)
+ 	if err := h.client.UseDB(dbName); err != nil {
+ 		return fmt.Errorf("failed to use database '%s': %w", dbName, err)
+ 	}
+ 	
+ 	return nil
  }
  
```

---

_**User**_

logの出力はslogを使用して欲しいですね

---

_**Assistant**_

I'll refactor the code to use the structured logging package `slog` instead of the standard `log` package. This will provide better structured logging capabilities.

---

```diff
  import (
  	"fmt"
- 	"log"
+ 	"log/slog"
+ 	"os"
  	"regexp"
  	"strings"
```

```diff
  	// storedProcRegex matches stored procedure definitions
  	storedProcRegex = regexp.MustCompile(`(?i)BEGIN\s+[\s\S]*?END`)
+ 	
+ 	// logger is the structured logger for the application
+ 	logger = slog.New(slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{
+ 		Level: slog.LevelInfo,
+ 	}))
  )
  
```

```diff
  func NewQueryHandler(client *client.Conn) *QueryHandler {
  	if client == nil {
- 		log.Fatal("MySQL client connection cannot be nil")
+ 		logger.Error("MySQL client connection cannot be nil")
+ 		os.Exit(1)
  	}
  	return &QueryHandler{
```

```diff
  // HandleQuery processes queries from clients
  func (h *QueryHandler) HandleQuery(query string) (*mysql.Result, error) {
- 	log.Printf("Handling query: %s", query)
+ 	logger.Info("Handling query", "query", query)
  
  	// Split query into multiple statements
  	queries, err := h.splitQuery(query)
  	if err != nil {
+ 		logger.Error("Failed to split query", "error", err)
  		return nil, err
  	}
```

```diff
  		res, err = h.client.Execute(trimQuery)
  		if err != nil {
+ 			logger.Error("Query execution error", "query", trimQuery, "error", err)
  			return nil, fmt.Errorf("query execution error: %w", err)
  		}
+ 		
+ 		logger.Debug("Query executed successfully", "query", trimQuery)
  	}
  
```

```diff
  	}
  	
- 	log.Printf("Using database: %s", dbName)
+ 	logger.Info("Using database", "dbName", dbName)
  	if err := h.client.UseDB(dbName); err != nil {
+ 		logger.Error("Failed to use database", "dbName", dbName, "error", err)
  		return fmt.Errorf("failed to use database '%s': %w", dbName, err)
  	}
```

```diff
  // HandleFieldList processes FIELD_LIST commands
  func (h *QueryHandler) HandleFieldList(table string, wildcard string) ([]*mysql.Field, error) {
- 	log.Printf("Handle field list request for table: %s, wildcard: %s", table, wildcard)
+ 	logger.Info("Handle field list request", "table", table, "wildcard", wildcard)
  	return nil, fmt.Errorf("field list not supported")
  }
  
  // HandleStmtPrepare processes Prepare statements
  func (h *QueryHandler) HandleStmtPrepare(query string) (int, int, interface{}, error) {
- 	log.Printf("Prepare statement request: %s", query)
+ 	logger.Info("Prepare statement request", "query", query)
  	return 0, 0, nil, fmt.Errorf("prepared statements not supported")
  }
  
  // HandleStmtExecute processes the execution of Prepare statements
  func (h *QueryHandler) HandleStmtExecute(context interface{}, query string, args []interface{}) (*mysql.Result, error) {
- 	log.Printf("Execute prepared statement: %s with args: %v", query, args)
+ 	logger.Info("Execute prepared statement", "query", query, "args", args)
  	return nil, fmt.Errorf("prepared statement execution not supported")
  }
  
  // HandleStmtClose processes the closing of Prepare statements
  func (h *QueryHandler) HandleStmtClose(context interface{}) error {
- 	log.Printf("Closing prepared statement")
+ 	logger.Info("Closing prepared statement")
  	return nil
  }
  
  // HandleOtherCommand processes other commands
  func (h *QueryHandler) HandleOtherCommand(cmd byte, data []byte) error {
- 	log.Printf("Handling other command: %d", cmd)
+ 	logger.Info("Handling other command", "cmd", cmd)
  	return fmt.Errorf("command not supported")
  }
```

---

