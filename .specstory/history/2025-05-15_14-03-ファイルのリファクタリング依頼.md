<!-- Generated by SpecStory -->

# ファイルのリファクタリング依頼 (2025-05-15 23:03:57)

_**User**_

このファイルをリファクタリングしてください

---

_**Assistant**_

リファクタリングを行います。いくつかの点で改善できますね。

---

```diff
  	"errors"
  	"fmt"
- 	"log"
  	"log/slog"
  	"net"
```

```diff
  )
  
- // Default timeout for graceful shutdown
+ // Connection pool configuration constants
+ const (
+ 	MinConnections     = 16
+ 	MaxConnections     = 64
+ 	MaxIdleConnections = 32
+ 	PoolPingTimeout    = 5 * time.Second
+ )
+ 
+ // Timeout constants
  const (
- 	MinConnections         = 16
- 	MaxConnections         = 64
- 	MaxIdleConnections     = 32
  	DefaultShutdownTimeout = 30 * time.Second
  )
  
- var errorConnectionClosed = errors.New("connection closed")
+ // Common error definitions
+ var (
+ 	ErrConnectionClosed = errors.New("connection closed")
+ )
  
- // DBConfig is a struct that holds database connection configuration information
+ // DBConfig holds database connection configuration
  type DBConfig struct {
  	DBName string
```

```diff
  	wg           *sync.WaitGroup
  	atomPool     atomic.Pointer[client.Pool]
+ 	logger       *slog.Logger
  }
  
```

```diff
  		wg:           wg,
  		atomPool:     atomic.Pointer[client.Pool]{},
+ 		logger:       slog.Default(),
  	}
  }
```

```diff
  func (s *ProxyServer) Start(ctx context.Context) error {
  	// Create a connection pool to the target database
- 	pool, err := client.NewPoolWithOptions(
- 		s.targetDbConf.Addr,
- 		s.targetDbConf.User,
- 		s.targetDbConf.Pass,
- 		s.targetDbConf.DBName,
- 		client.WithPoolLimits(MinConnections, MaxConnections, MaxIdleConnections),
- 		client.WithLogger(slog.Default()),
- 		client.WithNewPoolPingTimeout(5*time.Second),
- 	)
+ 	pool, err := s.createConnectionPool()
  	if err != nil {
- 		return fmt.Errorf("failed to create connection pool: %w", err)
+ 		return err
  	}
+ 	
  	// Store the connection pool in the atomic pointer
  	s.atomPool.Store(pool)
```

```diff
  		if err != nil {
  			if errors.Is(err, net.ErrClosed) {
- 				log.Println("Listener closed, exiting accept loop")
+ 				s.logger.Info("Listener closed, exiting accept loop")
  				break
  			}
- 			log.Printf("Failed to accept connection: %v", err)
+ 			s.logger.Error("Failed to accept connection", "error", err)
  			continue
  		}
```

```diff
  	return nil
  }
+ 
+ // createConnectionPool initializes the connection pool to the target database
+ func (s *ProxyServer) createConnectionPool() (*client.Pool, error) {
+ 	pool, err := client.NewPoolWithOptions(
+ 		s.targetDbConf.Addr,
+ 		s.targetDbConf.User,
+ 		s.targetDbConf.Pass,
+ 		s.targetDbConf.DBName,
+ 		client.WithPoolLimits(MinConnections, MaxConnections, MaxIdleConnections),
+ 		client.WithLogger(s.logger),
+ 		client.WithNewPoolPingTimeout(PoolPingTimeout),
+ 	)
+ 	if err != nil {
+ 		return nil, fmt.Errorf("failed to create connection pool: %w", err)
+ 	}
+ 	return pool, nil
+ }
  
  // handleConnection processes a new client connection
```

```diff
  	}()
  
- 	client, err := s.atomPool.Load().GetConn(ctx)
+ 	dbConn, err := s.getDBConnection(ctx)
+ 	if err != nil {
+ 		s.logger.Error("Failed to get connection from pool", "error", err)
+ 		return
+ 	}
+ 	defer s.atomPool.Load().PutConn(dbConn)
+ 
+ 	serverConn, err := s.createServerConnection(conn, dbConn)
  	if err != nil {
- 		log.Printf("Failed to get connection from pool: %v", err)
- 		conn.Close()
+ 		s.logger.Error("Failed to create server connection", "error", err)
  		return
  	}
- 	defer s.atomPool.Load().PutConn(client)
- 
- 	// Create MySQL server connection
- 	serverConn, err := server.NewDefaultServer().NewConn(
+ 
+ 	s.processCommands(serverConn)
+ }
+ 
+ // getDBConnection retrieves a connection from the pool
+ func (s *ProxyServer) getDBConnection(ctx context.Context) (*client.Conn, error) {
+ 	pool := s.atomPool.Load()
+ 	if pool == nil {
+ 		return nil, errors.New("connection pool not initialized")
+ 	}
+ 	return pool.GetConn(ctx)
+ }
+ 
+ // createServerConnection sets up the MySQL server connection
+ func (s *ProxyServer) createServerConnection(conn net.Conn, dbConn *client.Conn) (*server.Conn, error) {
+ 	return server.NewDefaultServer().NewConn(
  		conn,
  		s.listenDbConf.User,
  		s.listenDbConf.Pass,
- 		NewQueryHandler(client),
+ 		NewQueryHandler(dbConn),
  	)
- 	if err != nil {
- 		log.Printf("Failed to create server connection: %v", err)
- 		return
- 	}
+ }
  
- 	// Process commands until client disconnects
+ // processCommands handles MySQL commands until the client disconnects
+ func (s *ProxyServer) processCommands(serverConn *server.Conn) {
  	for {
  		if err := serverConn.HandleCommand(); err != nil {
- 			if err.Error() != errorConnectionClosed.Error() {
- 				log.Printf("Error handling command: %v", err)
+ 			if err.Error() != ErrConnectionClosed.Error() {
+ 				s.logger.Error("Error handling command", "error", err)
  			}
- 
  			break
  		}
```

```diff
  func (s *ProxyServer) Shutdown() {
  	if err := s.listener.Close(); err != nil {
- 		log.Printf("Failed to close listener: %v", err)
+ 		s.logger.Error("Failed to close listener", "error", err)
  	}
  
```

```diff
  	}()
  
- 	s.atomPool.Load().Close()
+ 	if pool := s.atomPool.Load(); pool != nil {
+ 		pool.Close()
+ 	}
  
  	select {
  	case <-done:
- 		log.Println("Server shutdown complete")
+ 		s.logger.Info("Server shutdown complete")
  	case <-time.After(DefaultShutdownTimeout):
- 		log.Println("Server shutdown timed out")
+ 		s.logger.Info("Server shutdown timed out")
  	}
  }
```

---

リファクタリングを完了しました。主な改善点：

1. 定数の整理と分類 - 役割ごとにグループ化
2. エラー定義をvar宣言グループにまとめ、命名規則を改善（errorConnectionClosed → ErrConnectionClosed）
3. ロガーの統一 - `log` パッケージから構造化ロギングの `slog` に統一
4. 大きな関数を小さな責任範囲を持つ関数に分割
   - createConnectionPool
   - getDBConnection
   - createServerConnection
   - processCommands
5. エラー処理の改善と一貫性
6. null安全なプールアクセス（Shutdown時）
7. 全体的なコードの明確さと可読性の向上
8. メソッド・定数へのドキュメンテーション追加

これらの変更により、コードは保守性が高く、理解しやすくなりました。

---

